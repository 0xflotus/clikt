{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Clikt (pronounced \u201cclicked\u201d) is a Kotlin library that makes writing command line interfaces simple and intuitive. It the \u201cCommand Line Interface for Kotlin\u201d. Inspired by Python\u2019s Click , it is designed to make the process of writing command line tools efortless while supporting a wide variety of use cases and allowing advanced customization when needed. Clikt has: arbitrary nesting of commands composable, type safe parameter values support for a wide variety of command line interface styles What does it look like? Here\u2019s a complete example of a simple Clikt program: class Hello : CliktCommand () { val count : Int by option ( help = \"Number of greetings\" ). int (). default ( 1 ) val name : String by option ( help = \"The person to greet\" ). prompt ( \"Your name\" ) override fun run () { for ( i in 1. . count ) { echo ( \"Hello $name!\" ) } } } fun main ( args : Array < String >) = Hello (). main ( args ) And here\u2019s what it looks like when run: $ ./hello --count=3 Your name: John Hello John! Hello John! Hello John! The help page is generated for you: $ ./hello --help Usage: hello [OPTIONS] Options: --count INT Number of greetings --name TEXT The person to greet -h, --help Show this message and exit Errors are also taken care of: $ ./hello --whoops Usage: hello [OPTIONS] Error: no such option: \"--whoops\". API Reference \u00b6 Commands and Exceptions Options Arguments Parameter Type Conversions Output Formatting License \u00b6 Copyright 2018 AJ Alt Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Clikt: Simple, powerful command line parser for Kotlin"},{"location":"#api-reference","text":"Commands and Exceptions Options Arguments Parameter Type Conversions Output Formatting","title":"API Reference"},{"location":"#license","text":"Copyright 2018 AJ Alt Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"advanced/","text":"Advanced Patters \u00b6 Clikt has reasonable behavior by default, but is also very customizable for advanced use cases. Command Aliases \u00b6 Clikt allows commands to alias command names to sequences of tokens. This allows you to implement common patterns like allowing the user to invoke a command by typing a prefix of its name, or user-defined aliases like the way you can configure git to accept git ci as an alias for git commit . To implement command aliases, override CliktCommand.aliases in your command. This function is called once at the start of parsing, and returns a map of aliases to the tokens that they alias to. To implement git-style aliases: class Repo : NoRunCliktCommand () { // You could load the aliases from a config file etc. override fun aliases (): Map < String , List < String >> = mapOf ( \"ci\" to listOf ( \"commit\" ), \"cm\" to listOf ( \"commit\" , \"-m\" ) ) } class Commit : CliktCommand () { val message by option ( \"-m\" ). default ( \"\" ) override fun run () { echo ( \"Committing with message: $message\" ) } } fun main ( args : Array < String >) = Repo (). subcommands ( Commit ()). main ( args ) And on the command line: $ ./repo ci -m 'my message' Committing with message: my message $ ./repo cm 'my message' Committing with message: my message Note that aliases are not expanded recursively: none of the tokens that an alias expands to will be expanded again, even if they match another alias. You also use this functionality to implement command prefixes: class Tool : CliktCommand () { override fun aliases (): Map < String , List < String >> { val prefixCounts = mutableMapOf < String , Int >(). withDefault { 0 } val prefixes = mutableMapOf < String , List < String >>() for ( name in registeredSubcommandNames ()) { if ( name . length < 3 ) continue for ( i in 1. . name . lastIndex ) { val prefix = name . substring ( 0. . i ) prefixCounts [ prefix ] = prefixCounts . getValue ( prefix ) + 1 prefixes [ prefix ] = listOf ( name ) } } return prefixes . filterKeys { prefixCounts . getValue ( it ) == 1 } } override fun run () = Unit } class Foo : CliktCommand () { override fun run () { echo ( \"Running Foo\" ) } } class Bar : CliktCommand () { override fun run () { echo ( \"Running Bar\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Foo (), Bar ()). main ( args ) Which allows you to call the subcommands like this: $ ./tool ba Running Bar Token Normalization \u00b6 To prevent ambiguities in parsing, aliases are only supported for command names. However, there\u2019s another way to modify user input that works on more types of tokens. You can set a tokenTransformer on the command\u2019s context that will be called for each option and command name that is input. This can be used to implement case-insensitive parsing, for example: class Hello : CliktCommand () { init { context { tokenTransformer = { it . toLowerCase () } } } val name by option () override fun run () = echo ( \"Hello $name!\" ) } $ ./hello --NAME=Foo Hello Foo! Replacing stdin and stdout \u00b6 By default, functions like CliktCommand.main and option().prompt() read from System.in and write to System.out . If you want to use clikt in an environment where the standard streams aren\u2019t available, you can set your own implementation of CliktConsole when customizing the command context . object MyConsole : CliktConsole { override fun promptForLine ( prompt : String , hideInput : Boolean ): String ? { MyOutputStream . write ( prompt ) return if ( hideInput ) MyInputStream . readPassword () else MyInputStream . readLine () } override fun print ( text : String , error : Boolean ) { if ( error ) MyOutputStream . writeError ( prompt ) else MyOutputStream . write ( prompt ) } override val lineSeparator : String get () = \"\\n\" } class CustomCLI : CliktCommand () { init { context { this . console = MyConsole } } override fun run () {} } If you are using TermUI directly, you can also pass your custom console as an argument.","title":"Command Aliases"},{"location":"advanced/#advanced-patters","text":"Clikt has reasonable behavior by default, but is also very customizable for advanced use cases.","title":"Advanced Patters"},{"location":"advanced/#command-aliases","text":"Clikt allows commands to alias command names to sequences of tokens. This allows you to implement common patterns like allowing the user to invoke a command by typing a prefix of its name, or user-defined aliases like the way you can configure git to accept git ci as an alias for git commit . To implement command aliases, override CliktCommand.aliases in your command. This function is called once at the start of parsing, and returns a map of aliases to the tokens that they alias to. To implement git-style aliases: class Repo : NoRunCliktCommand () { // You could load the aliases from a config file etc. override fun aliases (): Map < String , List < String >> = mapOf ( \"ci\" to listOf ( \"commit\" ), \"cm\" to listOf ( \"commit\" , \"-m\" ) ) } class Commit : CliktCommand () { val message by option ( \"-m\" ). default ( \"\" ) override fun run () { echo ( \"Committing with message: $message\" ) } } fun main ( args : Array < String >) = Repo (). subcommands ( Commit ()). main ( args ) And on the command line: $ ./repo ci -m 'my message' Committing with message: my message $ ./repo cm 'my message' Committing with message: my message Note that aliases are not expanded recursively: none of the tokens that an alias expands to will be expanded again, even if they match another alias. You also use this functionality to implement command prefixes: class Tool : CliktCommand () { override fun aliases (): Map < String , List < String >> { val prefixCounts = mutableMapOf < String , Int >(). withDefault { 0 } val prefixes = mutableMapOf < String , List < String >>() for ( name in registeredSubcommandNames ()) { if ( name . length < 3 ) continue for ( i in 1. . name . lastIndex ) { val prefix = name . substring ( 0. . i ) prefixCounts [ prefix ] = prefixCounts . getValue ( prefix ) + 1 prefixes [ prefix ] = listOf ( name ) } } return prefixes . filterKeys { prefixCounts . getValue ( it ) == 1 } } override fun run () = Unit } class Foo : CliktCommand () { override fun run () { echo ( \"Running Foo\" ) } } class Bar : CliktCommand () { override fun run () { echo ( \"Running Bar\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Foo (), Bar ()). main ( args ) Which allows you to call the subcommands like this: $ ./tool ba Running Bar","title":"Command Aliases"},{"location":"advanced/#token-normalization","text":"To prevent ambiguities in parsing, aliases are only supported for command names. However, there\u2019s another way to modify user input that works on more types of tokens. You can set a tokenTransformer on the command\u2019s context that will be called for each option and command name that is input. This can be used to implement case-insensitive parsing, for example: class Hello : CliktCommand () { init { context { tokenTransformer = { it . toLowerCase () } } } val name by option () override fun run () = echo ( \"Hello $name!\" ) } $ ./hello --NAME=Foo Hello Foo!","title":"Token Normalization"},{"location":"advanced/#replacing-stdin-and-stdout","text":"By default, functions like CliktCommand.main and option().prompt() read from System.in and write to System.out . If you want to use clikt in an environment where the standard streams aren\u2019t available, you can set your own implementation of CliktConsole when customizing the command context . object MyConsole : CliktConsole { override fun promptForLine ( prompt : String , hideInput : Boolean ): String ? { MyOutputStream . write ( prompt ) return if ( hideInput ) MyInputStream . readPassword () else MyInputStream . readLine () } override fun print ( text : String , error : Boolean ) { if ( error ) MyOutputStream . writeError ( prompt ) else MyOutputStream . write ( prompt ) } override val lineSeparator : String get () = \"\\n\" } class CustomCLI : CliktCommand () { init { context { this . console = MyConsole } } override fun run () {} } If you are using TermUI directly, you can also pass your custom console as an argument.","title":"Replacing stdin and stdout"},{"location":"arguments/","text":"Arguments \u00b6 Arguments are declared and customized similarly to options , but are provided on the command line positionally instead of by name. Arguments are declared with argument() , and the order that they are declared defines the order that they must be provided on the command line. Basic Arguments \u00b6 By default, argument takes a single String value which is required to be provided on the command line. class Hello : CliktCommand () { val name by argument () override fun run () { echo ( \"Hello $name!\" ) } } And on the command line: $ ./hello Foo Hello Foo! Arguments appear in the usage string, but normally aren\u2019t listed in the help page. It\u2019s usually more clear to document arguments in the command help. For example: class Cp : CliktCommand ( help = \"Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST.\" ) { private val source by argument (). file ( exists = true ). multiple () private val dest by argument (). file () override fun run () { // ... } } Which produces the following help: Usage: cp [OPTIONS] [SOURCE]... DEST Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST. Options: -h, --help Show this message and exit Variadic Arguments \u00b6 Like options , arguments can take any fixed number of values, which you can change with functions like pair and triple . Unlike options, arguments can take a variable (or unlimited) number of values. This is especially common when taking file paths, since they are frequently expanded with a glob pattern on the command line. You can declare any number of arguments with fixed numbers of values, but only one variadic argument. class Copy : CliktCommand () { val source by argument (). file ( exists = true ). multiple () val dest by argument (). file ( fileOkay = false ) override fun run () { echo ( \"Copying files $source to $dest\" ) } } And on the command line: $ ./copy file.* out/ Copying files [file.txt, file.md] to out/ Option-Like Arguments \u00b6 Clikt normally parses any value that starts with punctuation as an option, which allows users to intermix options and arguments. However, sometimes you need to pass a value that starts with punctuation to an argument. For example, you might have a file named -file.txt that you want to use as an argument. Clikt supports the POSIX convention of using -- to force all following values to be treated as arguments. Any values before the -- will be parsed normally. class Touch : CliktCommand () { val verbose by option (). flag () val files by argument (). multiple () override fun run () { if ( verbose ) echo ( files . joinToString ( \"\\n\" )) } } And on the command line: $ ./touch --foo.txt Usage: touch [OPTIONS] [FILES]... Error: no such option: \"--foo.txt\". $ ./touch --verbose -- --foo.txt bar.txt --foo.txt bar.txt","title":"Basic Arguments"},{"location":"arguments/#arguments","text":"Arguments are declared and customized similarly to options , but are provided on the command line positionally instead of by name. Arguments are declared with argument() , and the order that they are declared defines the order that they must be provided on the command line.","title":"Arguments"},{"location":"arguments/#basic-arguments","text":"By default, argument takes a single String value which is required to be provided on the command line. class Hello : CliktCommand () { val name by argument () override fun run () { echo ( \"Hello $name!\" ) } } And on the command line: $ ./hello Foo Hello Foo! Arguments appear in the usage string, but normally aren\u2019t listed in the help page. It\u2019s usually more clear to document arguments in the command help. For example: class Cp : CliktCommand ( help = \"Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST.\" ) { private val source by argument (). file ( exists = true ). multiple () private val dest by argument (). file () override fun run () { // ... } } Which produces the following help: Usage: cp [OPTIONS] [SOURCE]... DEST Copy SOURCE to DEST, or multiple SOURCE(s) to directory DEST. Options: -h, --help Show this message and exit","title":"Basic Arguments"},{"location":"arguments/#variadic-arguments","text":"Like options , arguments can take any fixed number of values, which you can change with functions like pair and triple . Unlike options, arguments can take a variable (or unlimited) number of values. This is especially common when taking file paths, since they are frequently expanded with a glob pattern on the command line. You can declare any number of arguments with fixed numbers of values, but only one variadic argument. class Copy : CliktCommand () { val source by argument (). file ( exists = true ). multiple () val dest by argument (). file ( fileOkay = false ) override fun run () { echo ( \"Copying files $source to $dest\" ) } } And on the command line: $ ./copy file.* out/ Copying files [file.txt, file.md] to out/","title":"Variadic Arguments"},{"location":"arguments/#option-like-arguments","text":"Clikt normally parses any value that starts with punctuation as an option, which allows users to intermix options and arguments. However, sometimes you need to pass a value that starts with punctuation to an argument. For example, you might have a file named -file.txt that you want to use as an argument. Clikt supports the POSIX convention of using -- to force all following values to be treated as arguments. Any values before the -- will be parsed normally. class Touch : CliktCommand () { val verbose by option (). flag () val files by argument (). multiple () override fun run () { if ( verbose ) echo ( files . joinToString ( \"\\n\" )) } } And on the command line: $ ./touch --foo.txt Usage: touch [OPTIONS] [FILES]... Error: no such option: \"--foo.txt\". $ ./touch --verbose -- --foo.txt bar.txt --foo.txt bar.txt","title":"Option-Like Arguments"},{"location":"commands/","text":"Commands \u00b6 Clikt supports arbitrarily nested commands. You can add one command as a child of another with the echo function, which can be called either in an init block, or on an existing instance. Executing Nested Commands \u00b6 For commands with no children, run is called whenever the command line is parsed (unless parsing is aborted from an error or an option like --help ). If a command has children, this isn\u2019t the case. Instead, its run is called only if a child command is invoked, just before the subcommand\u2019s run . If a parent command is called without specifying a subcommand, the help page is printed and run is not called. class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) override fun run () { echo ( \"Verbose mode is ${if (verbose) \" on \" else \" off \"}\" ) } } class Execute : CliktCommand () { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool Usage: tool [OPTIONS] COMMAND [ARGS]... Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Or: $ ./tool --verbose execute Verbose mode is on executing Customizing Command Name \u00b6 The default name for subcommands is inferred as a lowercase name from the command class name. You can also set a name manually in the CliktCommand constructor. class Tool : CliktCommand () { override fun run ()= Unit } class Execute : CliktCommand ( name = \"RUN-ME\" ) { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool RUN-ME executing $ ./tool -h Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: RUN-ME Passing Parameters \u00b6 When calling subcommands, the position of options and arguments on the command line affect which command will parse them. A parameter is parsed by a command if is occurs after the command name, but before any other command names. For example: class Tool : CliktCommand(help = \"A tool that runs\") { val verbose by option().flag(\"--no-verbose\") override fun run() = Unit } class Execute : CliktCommand(help = \"Execute the command\") { val name by option() override fun run() = Unit } fun main(args: Array<String>) = Tool().subcommands(Execute()).main(args) Which has the following behavior: $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... A tool that runs Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Execute the command If you instead execute --help after the subcommand, the subcommand\u2019s help is printed: $ ./tool execute --help Usage: execute [OPTIONS] Execute the command Options: --name TEXT -h, --help Show this message and exit But executing ./tool --help execute , with the option before the subcommand, will cause the parent\u2019s help option to be invoked, printing out Tool \u2018s help page as if you just typed ./tool --help . Nested Handling And Contexts \u00b6 Normally nested command are independent of each other: a child can\u2019t access its parent\u2019s parameters. This makes composing commands much easier, but what if you want to pass information to a child command? You can do so with the command\u2019s Context . Every time the command line is parsed, each command creates a new context object for itself that is liked to its parent\u2019s context. Context objects have a number of properties that can be used to customize command line parsing. Although each command creates its own context, the configuration is inherited from the parent context. Context objects also have an obj property that can hold any user defined data. You can use the obj to create interfaces like this: class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) val config by findObject { mutableMapOf < String , String >() } override fun run () { config [ \"VERBOSE\" ] = if ( verbose ) \"on\" else \"off\" } } class Execute : CliktCommand () { val config by requireObject < Map < String , String >>() override fun run () { echo ( \"Verbose mode is ${config[\" VERBOSE \"]}\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool --verbose execute Verbose mode is on The findObject and requireObject functions will walk up the context tree until they find an object with the given type. If no such object exists, they will either return null , throw an exception, or create an instance of the object and store it on the command\u2019s context, depending on which overload you call. Running Parent Command Without Children \u00b6 Normally, if a command has children, run is not called unless a child command is invoked on the command line. Instead, --help is called on the parent. If you want to change this behavior to always call run() on the parent, you can do so by setting invokeWithoutSubcommand to true . The Context will then have information on the subcommand that is about to be invoked, if there is one. class Tool : CliktCommand ( invokeWithoutSubcommand = true ) { override fun run () { if ( context . invokedSubcommand == null ) { echo ( \"invoked without a subcommand\" ) } else { echo ( \"about to run ${context.invokedSubcommand!!.commandName}\" ) } } } class Execute : CliktCommand () { override fun run () { echo ( \"running subcommand\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool invoked without a subcommand $./tool execute about to run execute running subcommand Customizing Contexts \u00b6 Contexts have a number of properties that can be customized, and which are inherited by child commands. You can change these properties with the context builder function, which can be called in an init block, or on a command instance. For example, you can change the default help message for the --help option. These definitions are equivalent: class Cli : NoRunCliktCommand () { init { context { helpOptionMessage = \"print the help\" } } } fun main ( args : Array < String >) = Cli (). main ( args ) and class Cli : NoRunCliktCommand () fun main ( args : Array < String >) = Cli () . context { helpOptionMessage = \"print the help\" } . main ( splitArgv ( \"\" )) Any they work like: $ ./cli --help Usage: cli [OPTIONS] Options: -h, --help print the help","title":"Executing Nested Commands"},{"location":"commands/#commands","text":"Clikt supports arbitrarily nested commands. You can add one command as a child of another with the echo function, which can be called either in an init block, or on an existing instance.","title":"Commands"},{"location":"commands/#executing-nested-commands","text":"For commands with no children, run is called whenever the command line is parsed (unless parsing is aborted from an error or an option like --help ). If a command has children, this isn\u2019t the case. Instead, its run is called only if a child command is invoked, just before the subcommand\u2019s run . If a parent command is called without specifying a subcommand, the help page is printed and run is not called. class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) override fun run () { echo ( \"Verbose mode is ${if (verbose) \" on \" else \" off \"}\" ) } } class Execute : CliktCommand () { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool Usage: tool [OPTIONS] COMMAND [ARGS]... Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Or: $ ./tool --verbose execute Verbose mode is on executing","title":"Executing Nested Commands"},{"location":"commands/#customizing-command-name","text":"The default name for subcommands is inferred as a lowercase name from the command class name. You can also set a name manually in the CliktCommand constructor. class Tool : CliktCommand () { override fun run ()= Unit } class Execute : CliktCommand ( name = \"RUN-ME\" ) { override fun run () { echo ( \"executing\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool RUN-ME executing $ ./tool -h Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: RUN-ME","title":"Customizing Command Name"},{"location":"commands/#passing-parameters","text":"When calling subcommands, the position of options and arguments on the command line affect which command will parse them. A parameter is parsed by a command if is occurs after the command name, but before any other command names. For example: class Tool : CliktCommand(help = \"A tool that runs\") { val verbose by option().flag(\"--no-verbose\") override fun run() = Unit } class Execute : CliktCommand(help = \"Execute the command\") { val name by option() override fun run() = Unit } fun main(args: Array<String>) = Tool().subcommands(Execute()).main(args) Which has the following behavior: $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... A tool that runs Options: --verbose / --no-verbose -h, --help Show this message and exit Commands: execute Execute the command If you instead execute --help after the subcommand, the subcommand\u2019s help is printed: $ ./tool execute --help Usage: execute [OPTIONS] Execute the command Options: --name TEXT -h, --help Show this message and exit But executing ./tool --help execute , with the option before the subcommand, will cause the parent\u2019s help option to be invoked, printing out Tool \u2018s help page as if you just typed ./tool --help .","title":"Passing Parameters"},{"location":"commands/#nested-handling-and-contexts","text":"Normally nested command are independent of each other: a child can\u2019t access its parent\u2019s parameters. This makes composing commands much easier, but what if you want to pass information to a child command? You can do so with the command\u2019s Context . Every time the command line is parsed, each command creates a new context object for itself that is liked to its parent\u2019s context. Context objects have a number of properties that can be used to customize command line parsing. Although each command creates its own context, the configuration is inherited from the parent context. Context objects also have an obj property that can hold any user defined data. You can use the obj to create interfaces like this: class Tool : CliktCommand () { val verbose by option (). flag ( \"--no-verbose\" ) val config by findObject { mutableMapOf < String , String >() } override fun run () { config [ \"VERBOSE\" ] = if ( verbose ) \"on\" else \"off\" } } class Execute : CliktCommand () { val config by requireObject < Map < String , String >>() override fun run () { echo ( \"Verbose mode is ${config[\" VERBOSE \"]}\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool --verbose execute Verbose mode is on The findObject and requireObject functions will walk up the context tree until they find an object with the given type. If no such object exists, they will either return null , throw an exception, or create an instance of the object and store it on the command\u2019s context, depending on which overload you call.","title":"Nested Handling And Contexts"},{"location":"commands/#running-parent-command-without-children","text":"Normally, if a command has children, run is not called unless a child command is invoked on the command line. Instead, --help is called on the parent. If you want to change this behavior to always call run() on the parent, you can do so by setting invokeWithoutSubcommand to true . The Context will then have information on the subcommand that is about to be invoked, if there is one. class Tool : CliktCommand ( invokeWithoutSubcommand = true ) { override fun run () { if ( context . invokedSubcommand == null ) { echo ( \"invoked without a subcommand\" ) } else { echo ( \"about to run ${context.invokedSubcommand!!.commandName}\" ) } } } class Execute : CliktCommand () { override fun run () { echo ( \"running subcommand\" ) } } fun main ( args : Array < String >) = Tool (). subcommands ( Execute ()). main ( args ) And on the command line: $ ./tool invoked without a subcommand $./tool execute about to run execute running subcommand","title":"Running Parent Command Without Children"},{"location":"commands/#customizing-contexts","text":"Contexts have a number of properties that can be customized, and which are inherited by child commands. You can change these properties with the context builder function, which can be called in an init block, or on a command instance. For example, you can change the default help message for the --help option. These definitions are equivalent: class Cli : NoRunCliktCommand () { init { context { helpOptionMessage = \"print the help\" } } } fun main ( args : Array < String >) = Cli (). main ( args ) and class Cli : NoRunCliktCommand () fun main ( args : Array < String >) = Cli () . context { helpOptionMessage = \"print the help\" } . main ( splitArgv ( \"\" )) Any they work like: $ ./cli --help Usage: cli [OPTIONS] Options: -h, --help print the help","title":"Customizing Contexts"},{"location":"documenting/","text":"Documenting Scripts \u00b6 Clikt takes care of creating formatted help messages for commands. There are a number of ways to customize the default behavior. You can also implement your own HelpFormatter and set it on the command\u2019s context . Help Texts \u00b6 Commands and parameters accept a help argument. Commands also accept an epilog argument, which is printed after the parameters and commands on the help page. All text is automatically re-wrapped to the terminal width. class Hello : CliktCommand ( help = \"\"\" This script prints NAME COUNT times . COUNT must be a positive number , and defaults to 1. \"\"\") { val count by option ( \"-c\" , \"--count\" , help = \"number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () = repeat ( count ) { echo ( \"Hello $name!\" ) } } Which creates the following help page: $ ./hello --help Usage: hello [OPTIONS] NAME This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. Options: -c, --count INT number of greetings -h, --help Show this message and exit Option names and metavars will appear in help output even if no help string is specified for them. On the other hand, arguments only appear in the usage string. It is possible to add a help string to arguments which will be added to the help page, but the Unix convention is to just describe arguments in the command help. Subcommand Short Help \u00b6 Subcommands are listed in the help page based on their name . They have a short help string which is the first line of their help. class Tool : NoRunCliktCommand() class Execute : NoRunCliktCommand(help = \"\"\" Execute the command. The command will be executed. \"\"\") class Abort : NoRunCliktCommand(help=\"Kill any running commands.\") Which generates this help page: $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: execute Execute the command. abort Kill any running commands. Help Option Customization \u00b6 Clikt handles the help option is specially. It is added automatically to every command. Any help option name that conflicts with another option is not used for the help option. If the help option has no unique names, it is not added. You can change the help option\u2019s name and help message on the command\u2019s context : class Tool : NoRunCliktCommand() { init { context { helpOptionNames = setOf(\"/help\") helpOptionMessage = \"show the help\" } } } And on the command line: $ ./tool /help Usage: tool [OPTIONS] Options: /help show the help If you don\u2019t want a help option to be added, you can set helpOptionNames = emptySet()","title":"Help Texts"},{"location":"documenting/#documenting-scripts","text":"Clikt takes care of creating formatted help messages for commands. There are a number of ways to customize the default behavior. You can also implement your own HelpFormatter and set it on the command\u2019s context .","title":"Documenting Scripts"},{"location":"documenting/#help-texts","text":"Commands and parameters accept a help argument. Commands also accept an epilog argument, which is printed after the parameters and commands on the help page. All text is automatically re-wrapped to the terminal width. class Hello : CliktCommand ( help = \"\"\" This script prints NAME COUNT times . COUNT must be a positive number , and defaults to 1. \"\"\") { val count by option ( \"-c\" , \"--count\" , help = \"number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () = repeat ( count ) { echo ( \"Hello $name!\" ) } } Which creates the following help page: $ ./hello --help Usage: hello [OPTIONS] NAME This script prints NAME COUNT times. COUNT must be a positive number, and defaults to 1. Options: -c, --count INT number of greetings -h, --help Show this message and exit Option names and metavars will appear in help output even if no help string is specified for them. On the other hand, arguments only appear in the usage string. It is possible to add a help string to arguments which will be added to the help page, but the Unix convention is to just describe arguments in the command help.","title":"Help Texts"},{"location":"documenting/#subcommand-short-help","text":"Subcommands are listed in the help page based on their name . They have a short help string which is the first line of their help. class Tool : NoRunCliktCommand() class Execute : NoRunCliktCommand(help = \"\"\" Execute the command. The command will be executed. \"\"\") class Abort : NoRunCliktCommand(help=\"Kill any running commands.\") Which generates this help page: $ ./tool --help Usage: tool [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: execute Execute the command. abort Kill any running commands.","title":"Subcommand Short Help"},{"location":"documenting/#help-option-customization","text":"Clikt handles the help option is specially. It is added automatically to every command. Any help option name that conflicts with another option is not used for the help option. If the help option has no unique names, it is not added. You can change the help option\u2019s name and help message on the command\u2019s context : class Tool : NoRunCliktCommand() { init { context { helpOptionNames = setOf(\"/help\") helpOptionMessage = \"show the help\" } } } And on the command line: $ ./tool /help Usage: tool [OPTIONS] Options: /help show the help If you don\u2019t want a help option to be added, you can set helpOptionNames = emptySet()","title":"Help Option Customization"},{"location":"exceptions/","text":"Exception Handling \u00b6 Clikt uses exceptions internally to signal that processing has ended early for any reason. This includes incorrect command line usage, or printing a help page. Where are Exceptions Handled? {#handling} \u00b6 When you call CliktCommand.main , it will parse the command line and catch any CliktError and Abort exceptions. If it catches one, it will then print out the appropriate information and exit the process. If the caught exception is a PrintMessage or PrintHelpMessage , the process exit status will be 0 and the message will be printed to stdout. Otherwise it will exit with status 1 and print the message to stderr. Any other types of exceptions indicate a programming error, and are not caught by main . However, convert and the other parameter transformations will wrap exceptions thrown inside them in a UsageError , so if you define a custom transformation, you don\u2019t have to worry about an exception escaping to the user. Handling Exceptions Manually \u00b6 CliktCommand.main is just a try / catch block surrounding CliktCommand.parse , so if don\u2019t want exceptions to be caught, you can call parse wherever you would normally call main . fun main ( args : Array < String >) = Cli (). parse ( args ) Which Exceptions Exist? \u00b6 Clikt will throw Abort if it needs to halt execution immediately without a specific message. All other exceptions are subclasses of UsageError . The following subclasses exist: PrintMessage : The exception\u2019s message should be printed. PrintHelpMessage : The help page for the exception\u2019s command should be printed. UsageError : The command line was incorrect in some way. All other exceptions subclass from this. These exceptions are automatically augmented with extra information about the current parameter, if possible. BadParameterValue : A parameter was given the correct number of values, but of invalid format or type. MissingParameter : A required parameter was not provided. NoSuchOption : An option was provided that does not exist. IncorrectOptionValueCount : An option was supplied but the number of values supplied to the option was incorrect. IncorrectArgumentValueCount : An argument was supplied but the number of values supplied was incorrect.","title":"Where are Exceptions Handled?"},{"location":"exceptions/#exception-handling","text":"Clikt uses exceptions internally to signal that processing has ended early for any reason. This includes incorrect command line usage, or printing a help page.","title":"Exception Handling"},{"location":"exceptions/#where-are-exceptions-handled-handling","text":"When you call CliktCommand.main , it will parse the command line and catch any CliktError and Abort exceptions. If it catches one, it will then print out the appropriate information and exit the process. If the caught exception is a PrintMessage or PrintHelpMessage , the process exit status will be 0 and the message will be printed to stdout. Otherwise it will exit with status 1 and print the message to stderr. Any other types of exceptions indicate a programming error, and are not caught by main . However, convert and the other parameter transformations will wrap exceptions thrown inside them in a UsageError , so if you define a custom transformation, you don\u2019t have to worry about an exception escaping to the user.","title":"Where are Exceptions Handled? {#handling}"},{"location":"exceptions/#handling-exceptions-manually","text":"CliktCommand.main is just a try / catch block surrounding CliktCommand.parse , so if don\u2019t want exceptions to be caught, you can call parse wherever you would normally call main . fun main ( args : Array < String >) = Cli (). parse ( args )","title":"Handling Exceptions Manually"},{"location":"exceptions/#which-exceptions-exist","text":"Clikt will throw Abort if it needs to halt execution immediately without a specific message. All other exceptions are subclasses of UsageError . The following subclasses exist: PrintMessage : The exception\u2019s message should be printed. PrintHelpMessage : The help page for the exception\u2019s command should be printed. UsageError : The command line was incorrect in some way. All other exceptions subclass from this. These exceptions are automatically augmented with extra information about the current parameter, if possible. BadParameterValue : A parameter was given the correct number of values, but of invalid format or type. MissingParameter : A required parameter was not provided. NoSuchOption : An option was provided that does not exist. IncorrectOptionValueCount : An option was supplied but the number of values supplied to the option was incorrect. IncorrectArgumentValueCount : An argument was supplied but the number of values supplied was incorrect.","title":"Which Exceptions Exist?"},{"location":"options/","text":"Options \u00b6 Options are added to commands by defining a property delegate with the option function. Basic Options \u00b6 The default option takes one value of type String . The property is nullable. If the option is not given on the command line, the property value will be null. If the option is given at least once, the property will return the value of the last occurrence of the option. class Hello : CliktCommand () { val name by option ( help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } And on the command line: $ ./hello --name=Foo Hello, Foo! Option Names \u00b6 If you don\u2019t specify names for an option, a lowercase hyphen-separated name is automatically inferred from the property. For example, val myOpt by option() will create an option that can be called with --my-opt . You can also specify any number of names for an option manually: class Hello : CliktCommand () { val name by option ( \"-n\" , \"--name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } Option names that are two characters long (like -n ) are treated as POSIX-style short options. You call them with a value like this: $ ./hello -nfoo Hello, foo! or: $ ./hello -n foo Hello, foo! All other option names are considered long options, and can be called like this: $ ./hello --name=foo Hello, foo! or: $ ./hello --name foo Hello, foo! Customizing Options \u00b6 The option behavior and delegate type can be customized by calling extension functions on the option call. For example, here are some different option declarations: val a : String ? by option () val b : Int ? by option (). int () val c : Pair < Int , Int >? by option (). int (). pair () val d : Pair < Int , Int > by option (). int (). pair (). default ( 0 to 0 ) val e : Pair < Float , Float > by option (). float (). pair (). default ( 0f to 0f ) There are three main types of behavior that can be customized independently: The type of each value in the option The value type is String by default, but can be customized with built-in functions like int or choice , or manually with convert . This is detailed in the parameters page. The number of values that the option requires Options take one value by default, but this can be changed with built-in functions like pair and triple , or manually with transformValues . How to handle all calls to the option (i.e. if the option is not given, or is given more than once). By default, the option delegate value is the null if the option is not given on the command line, but you can change this behavior with functions like default and multiple . Since the three types of customizations are orthogonal, you can choose which ones you want to use, and if you implement a new customization, it can be used with all of the existing functions without any repeated code. Default Values \u00b6 By default, option delegates return null if the option wasn\u2019t provided on the command line. You can instead return a default value with default . class Pow : CliktCommand () { val exp by option ( \"-e\" , \"--exp\" ). double (). default ( 1.0 ) override fun run () { echo ( \"2 ^ $exp = ${Math.pow(2.0, exp)}\" ) } } And on the command line: $ ./pow -e 8 2 ^ 8.0 = 256.0 $ ./pow 2 ^ 1.0 = 2.0 If the default value is expensive to compute, you can use defaultLazy instead of default . It has the same effect, but you give it a lambda returning the default value, and the lambda will only be called if the default value is used. Multi Value Options \u00b6 Options can take any fixed number of values. If you want a variable number of values, you need to use and argument instead. There are built in functions for options that take two values ( pair , which uses a Pair ), or three values ( triple , which uses a Triple ). You can change the type of each value as normal with functions like int . If you need more values, you can provide your own container with transformValues . You give that function the number of values you want, and a lambda that will transform a list of values into the output container. The list will always have a size equal to the number you specify. If the user provides a different number of values, Clikt will inform the user and your lambda won\u2019t be called. data class Quad < out T >( val a : T , val b : T , val c : T , val d : T ) fun < T > Quad < T >. toList (): List < T > = listOf ( a , b , c , d ) class Geometry : CliktCommand () { val square by option (). int (). pair () val cube by option (). int (). triple () val tesseract by option (). int (). transformValues ( 4 ) { Quad ( it [ 0 ], it [ 1 ], it [ 2 ], it [ 3 ]) } override fun run () { echo ( \"Square has dimensions ${square?.toList()?.joinToString(\" x \")}\" ) echo ( \"Cube has dimensions ${cube?.toList()?.joinToString(\" x \")}\" ) echo ( \"Tesseract has dimensions ${tesseract?.toList()?.joinToString(\" x \")}\" ) } } And on the command line: $ ./geometry --square 1 2 --cube 3 4 5 --tesseract 6 7 8 9 Square has dimensions 1x2 Cube has dimensions 3x4x5 Tesseract has dimensions 6x7x8x9 Multiple Options \u00b6 Normally, when an option is provided on the command line more than once, only the values from the last occurrence are used. But sometimes you want to keep all values provided. For example, git commit -m foo -m bar would create a commit message with two lines: foo and bar . To get this behavior with Clikt, you can use multiple . This will cause the property delegate value to be a list, where each item in the list is the value of from one occurrence of the option. If the option is never given, the list will be empty (or you can specify a list to use). class Commit : CliktCommand () { val message by option ( \"-m\" ). multiple () override fun run () { echo ( message . joinToString ( \"\\n\" )) } } And on the command line: $ ./commit -m foo -m bar foo bar You can combine multiple with item type conversions and multiple values. For example: val opt : List < Pair < Int , Int >> option (). int (). pair (). multiple () Boolean Flag Options \u00b6 Flags are options that don\u2019t take a value. Boolean flags can be enabled or disabled, depending on the name used to invoke the option. You can turn an option into a boolean flag with flag . That function takes an optional list of secondary names that will be added to any existing or inferred names for the option. If the option is invoked with one of the secondary names, the delegate will return false. It\u2019s a good idea to always set secondary names so that a user can disable the flag if it was enabled previously. class Cli : CliktCommand () { val flag by option ( \"--on\" , \"-o\" ). flag ( \"--off\" , \"-O\" , default = false ) override fun run () { echo ( flag ) } } And on the command line: $ ./cli -o true $ ./cli --on --off false Multiple short flag options can be combined when called on the command line: class Cli : CliktCommand () { val flagA by option ( \"-a\" ). flag () val flagB by option ( \"-b\" ). flag () val foo by option ( \"-f\" ) override fun run () { echo ( \"$flagA $flagB $foo\" ) } } And on the command line: $ ./cli -abfFoo true true Foo Counted Flag Options \u00b6 You might want a flag option that counts the number of times it occurs on the command line. You can use counted for this. class Log : CliktCommand () { val verbosity by option ( \"-v\" ). counted () override fun run () { echo ( \"Verbosity level: $verbosity\" ) } } And on the command line: $ ./log -vvv Verbosity level: 3 Feature Switch Flags \u00b6 Another way to use flags to to assign a value to each option name. You can do this with switch , which takes a map of option names to values. Note that the names in the map replace any previously specified or inferred names. class Size : CliktCommand () { val size by option (). switch ( \"--large\" to \"large\" , \"--small\" to \"small\" ). default ( \"unknown\" ) override fun run () { echo ( \"You picked size $size\" ) } } And on the command line: $ ./size --small You picked size small Choice Options \u00b6 You can restrict the values that a regular option can take to a set of values using choice . You can also map the input values to new types. class Digest : CliktCommand () { val hash by option (). choice ( \"md5\" , \"sha1\" ) override fun run () { echo ( hash ) } } And on the command line: $ ./digest --hash=md5 md5 $ ./digest --hash=sha256 Usage: digest [OPTIONS] Error: Invalid value for \"--hash\": invalid choice: sha256. (choose from md5, sha1) $ ./digest --help Usage: digest [OPTIONS] Options: --hash [md5|sha1] -h, --help Show this message and exit Prompting For Input \u00b6 In some cases, you might want to create an option that uses the value given on the command line if there is one, but prompt the user for input if one is not provided. Clikt can take care of this for you with the prompt function. class Hello : CliktCommand () { val name by option (). prompt () override fun run () { echo ( \"Hello $name\" ) } } Which behaves like: ./hello --name=foo Hello foo ./hello Name: foo Hello foo The default prompt string is based on the option name, but prompt takes a number of parameters to customize the output. Password Prompts \u00b6 You can also create a option that uses a hidden prompt and asks for confirmation. This combination of behavior is commonly used for passwords. class Login : CliktCommand () { val password by option (). prompt ( requireConfirmation = true , hideInput = true ) override fun run () { echo ( \"Your hidden password: $password\" ) } } And on the command line: $ ./login Password: Repeat for confirmation: Your hidden password: hunter2 Eager Options \u00b6 Sometimes you want an option to halt execution immediately and print a message. For example, the built-on --help option, or the --version option that many programs have. Neither of these options have any value associated with them, and they stop command line parsing as soon as they\u2019re encountered. The --help option is added automatically to commands, and --version can be added using versionOption . Since the option doesn\u2019t have a value, you can\u2019t define it using a property delegate. Instead, call the function on a command directly, either in an init block, or on a command instance. These definitions are equivalent: class Cli : NoRunCliktCommand () { init { versionOption ( \"1.0\" ) } } fun main ( args : Array < String >) = Cli (). main ( args ) and class Cli : NoRunCliktCommand () fun main ( args : Array < String >) = Cli (). versionOption ( \"1.0\" ). main ( args ) Any they work like: $ ./cli --version cli version 1.0 If you want to define your own option with a similar behavior, you can do so by creating an instance of EagerOption and passing it to CliktCommand.registerOption . EagerOption s have a callback that is called when the option is encountered on the command line. To print a message and halt execution normally from the callback, you can throw a PrintMessage exception, and CliktCommand.main will take care of printing the message. You can define your own version option like this: class Cli : CliktCommand () { init { registerOption ( EagerOption ( \"--version\" ) { throw PrintMessage ( \"$commandName version 1.0\" ) }) } override fun run () { // ... } } Values From Environment Variables \u00b6 Clikt supports reading option values from environment variables if they aren\u2019t given on the command line. This feature is helpful when automating tools. For example, when using git commit , you can set the author date with a command line parameter: git commit --date=10/21/2015 . But you can also set it with an environment variable: GIT_AUTHOR_DATE=10/21/2015 git commit . Clikt will read option values from environment variables as long as it has an envvar name for the option. There are two ways to set that name: you can set the name manually for an option, or you can enable automatic envvar name inference. To set the envvar name manually, pass the name to option : class Hello : CliktCommand () { val name by option ( envvar = \"MY_NAME\" ) override fun run () { echo ( \"Hello $name\" ) } } And on the command line: $ export MY_NAME=Foo $ ./hello Hello Foo $ export MY_NAME=Foo $ ./hello --name=Bar Hello Bar You can enable automatic envvar name inference by setting the autoEnvvarPrefix on a command\u2019s context . This will cause all options without an explicit envvar name to be given an uppercase underscore-separated envvar name. Since the prefix is set on the context , it is propagated to subcommands. If you have a a subcommand called foo with an option --bar , and your prefix is MY_TOOL , the option\u2019s envvar name will be MY_TOOL_FOO_BAR . class Hello : CliktCommand () { init { context { autoEnvvarPrefix = \"HELLO\" } } val name by option () override fun run () { echo ( \"Hello $name\" ) } } And on the command line: $ export HELLO_NAME=Foo $ ./hello Hello Foo Multiple Values from Environment Variables \u00b6 You might need to allow users to specify multiple values for an option in a single environment variable. You can do this by creating an option with multiple . The environment variable\u2019s value will be split according a regex, which defaults to split on whitespace for most types. file will change the pattern to split according to the operating system\u2019s path splitting rules. On Windows, it will split on semicolons ( ; ). On other systems, it will split on colons ( : ). class Hello : CliktCommand () { val names by option ( envvar = \"NAMES\" ). multiple () override fun run () { for ( name in names ) echo ( \"Hello $name\" ) } } And on the command line: $ export NAMES=Foo Bar $ ./hello Hello Foo Hello Bar Windows and Java-Style Option Prefixes \u00b6 When specifying option names manually, you can use any prefix (as long as it\u2019s entirely punctuation). For example, you can make a Windows-style interface with slashes: class Hello : CliktCommand () { val name by option ( \"/name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } An on the command line: $ ./hello /name Foo Hello, Foo! Or you can make a Java-style interface that uses single-dashes for long options: class Hello : CliktCommand () { val name by option ( \"-name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } An on the command line: $ ./hello -name Foo Hello, Foo! Note that inferred names will always have a POSIX-style prefix like --name . If you want to use a different prefix, you should specify all option names manually. Option Transformation Order \u00b6 Clikt has a large number of extension functions that can modify options. When applying multiple functions to the same option, there\u2019s only one valid order for the functions to be applied. For example, option().default(3).int() will not compile, because default must be applied after the value type conversion. Similarly, you can only apply one transform of each type. So option().int().float() is invalid since int and float both change the value type, as is option().default(\"\").multiple() since default and multiple both transform the call list (if you need a custom default value for multiple , you can pass it one as an argument). Here\u2019s an integer option with one of each available transform in a valid order: val opt : Pair < Int , Int > by option ( \"-o\" , \"--opt\" ) . int () . restrictTo ( 1. . 100 ) . pair () . default ( 1 to 2 ) . validate { require ( it . second % 2 == 0 ) }","title":"Basic Options"},{"location":"options/#options","text":"Options are added to commands by defining a property delegate with the option function.","title":"Options"},{"location":"options/#basic-options","text":"The default option takes one value of type String . The property is nullable. If the option is not given on the command line, the property value will be null. If the option is given at least once, the property will return the value of the last occurrence of the option. class Hello : CliktCommand () { val name by option ( help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } And on the command line: $ ./hello --name=Foo Hello, Foo!","title":"Basic Options"},{"location":"options/#option-names","text":"If you don\u2019t specify names for an option, a lowercase hyphen-separated name is automatically inferred from the property. For example, val myOpt by option() will create an option that can be called with --my-opt . You can also specify any number of names for an option manually: class Hello : CliktCommand () { val name by option ( \"-n\" , \"--name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } Option names that are two characters long (like -n ) are treated as POSIX-style short options. You call them with a value like this: $ ./hello -nfoo Hello, foo! or: $ ./hello -n foo Hello, foo! All other option names are considered long options, and can be called like this: $ ./hello --name=foo Hello, foo! or: $ ./hello --name foo Hello, foo!","title":"Option Names"},{"location":"options/#customizing-options","text":"The option behavior and delegate type can be customized by calling extension functions on the option call. For example, here are some different option declarations: val a : String ? by option () val b : Int ? by option (). int () val c : Pair < Int , Int >? by option (). int (). pair () val d : Pair < Int , Int > by option (). int (). pair (). default ( 0 to 0 ) val e : Pair < Float , Float > by option (). float (). pair (). default ( 0f to 0f ) There are three main types of behavior that can be customized independently: The type of each value in the option The value type is String by default, but can be customized with built-in functions like int or choice , or manually with convert . This is detailed in the parameters page. The number of values that the option requires Options take one value by default, but this can be changed with built-in functions like pair and triple , or manually with transformValues . How to handle all calls to the option (i.e. if the option is not given, or is given more than once). By default, the option delegate value is the null if the option is not given on the command line, but you can change this behavior with functions like default and multiple . Since the three types of customizations are orthogonal, you can choose which ones you want to use, and if you implement a new customization, it can be used with all of the existing functions without any repeated code.","title":"Customizing Options"},{"location":"options/#default-values","text":"By default, option delegates return null if the option wasn\u2019t provided on the command line. You can instead return a default value with default . class Pow : CliktCommand () { val exp by option ( \"-e\" , \"--exp\" ). double (). default ( 1.0 ) override fun run () { echo ( \"2 ^ $exp = ${Math.pow(2.0, exp)}\" ) } } And on the command line: $ ./pow -e 8 2 ^ 8.0 = 256.0 $ ./pow 2 ^ 1.0 = 2.0 If the default value is expensive to compute, you can use defaultLazy instead of default . It has the same effect, but you give it a lambda returning the default value, and the lambda will only be called if the default value is used.","title":"Default Values"},{"location":"options/#multi-value-options","text":"Options can take any fixed number of values. If you want a variable number of values, you need to use and argument instead. There are built in functions for options that take two values ( pair , which uses a Pair ), or three values ( triple , which uses a Triple ). You can change the type of each value as normal with functions like int . If you need more values, you can provide your own container with transformValues . You give that function the number of values you want, and a lambda that will transform a list of values into the output container. The list will always have a size equal to the number you specify. If the user provides a different number of values, Clikt will inform the user and your lambda won\u2019t be called. data class Quad < out T >( val a : T , val b : T , val c : T , val d : T ) fun < T > Quad < T >. toList (): List < T > = listOf ( a , b , c , d ) class Geometry : CliktCommand () { val square by option (). int (). pair () val cube by option (). int (). triple () val tesseract by option (). int (). transformValues ( 4 ) { Quad ( it [ 0 ], it [ 1 ], it [ 2 ], it [ 3 ]) } override fun run () { echo ( \"Square has dimensions ${square?.toList()?.joinToString(\" x \")}\" ) echo ( \"Cube has dimensions ${cube?.toList()?.joinToString(\" x \")}\" ) echo ( \"Tesseract has dimensions ${tesseract?.toList()?.joinToString(\" x \")}\" ) } } And on the command line: $ ./geometry --square 1 2 --cube 3 4 5 --tesseract 6 7 8 9 Square has dimensions 1x2 Cube has dimensions 3x4x5 Tesseract has dimensions 6x7x8x9","title":"Multi Value Options"},{"location":"options/#multiple-options","text":"Normally, when an option is provided on the command line more than once, only the values from the last occurrence are used. But sometimes you want to keep all values provided. For example, git commit -m foo -m bar would create a commit message with two lines: foo and bar . To get this behavior with Clikt, you can use multiple . This will cause the property delegate value to be a list, where each item in the list is the value of from one occurrence of the option. If the option is never given, the list will be empty (or you can specify a list to use). class Commit : CliktCommand () { val message by option ( \"-m\" ). multiple () override fun run () { echo ( message . joinToString ( \"\\n\" )) } } And on the command line: $ ./commit -m foo -m bar foo bar You can combine multiple with item type conversions and multiple values. For example: val opt : List < Pair < Int , Int >> option (). int (). pair (). multiple ()","title":"Multiple Options"},{"location":"options/#boolean-flag-options","text":"Flags are options that don\u2019t take a value. Boolean flags can be enabled or disabled, depending on the name used to invoke the option. You can turn an option into a boolean flag with flag . That function takes an optional list of secondary names that will be added to any existing or inferred names for the option. If the option is invoked with one of the secondary names, the delegate will return false. It\u2019s a good idea to always set secondary names so that a user can disable the flag if it was enabled previously. class Cli : CliktCommand () { val flag by option ( \"--on\" , \"-o\" ). flag ( \"--off\" , \"-O\" , default = false ) override fun run () { echo ( flag ) } } And on the command line: $ ./cli -o true $ ./cli --on --off false Multiple short flag options can be combined when called on the command line: class Cli : CliktCommand () { val flagA by option ( \"-a\" ). flag () val flagB by option ( \"-b\" ). flag () val foo by option ( \"-f\" ) override fun run () { echo ( \"$flagA $flagB $foo\" ) } } And on the command line: $ ./cli -abfFoo true true Foo","title":"Boolean Flag Options"},{"location":"options/#counted-flag-options","text":"You might want a flag option that counts the number of times it occurs on the command line. You can use counted for this. class Log : CliktCommand () { val verbosity by option ( \"-v\" ). counted () override fun run () { echo ( \"Verbosity level: $verbosity\" ) } } And on the command line: $ ./log -vvv Verbosity level: 3","title":"Counted Flag Options"},{"location":"options/#feature-switch-flags","text":"Another way to use flags to to assign a value to each option name. You can do this with switch , which takes a map of option names to values. Note that the names in the map replace any previously specified or inferred names. class Size : CliktCommand () { val size by option (). switch ( \"--large\" to \"large\" , \"--small\" to \"small\" ). default ( \"unknown\" ) override fun run () { echo ( \"You picked size $size\" ) } } And on the command line: $ ./size --small You picked size small","title":"Feature Switch Flags"},{"location":"options/#choice-options","text":"You can restrict the values that a regular option can take to a set of values using choice . You can also map the input values to new types. class Digest : CliktCommand () { val hash by option (). choice ( \"md5\" , \"sha1\" ) override fun run () { echo ( hash ) } } And on the command line: $ ./digest --hash=md5 md5 $ ./digest --hash=sha256 Usage: digest [OPTIONS] Error: Invalid value for \"--hash\": invalid choice: sha256. (choose from md5, sha1) $ ./digest --help Usage: digest [OPTIONS] Options: --hash [md5|sha1] -h, --help Show this message and exit","title":"Choice Options"},{"location":"options/#prompting-for-input","text":"In some cases, you might want to create an option that uses the value given on the command line if there is one, but prompt the user for input if one is not provided. Clikt can take care of this for you with the prompt function. class Hello : CliktCommand () { val name by option (). prompt () override fun run () { echo ( \"Hello $name\" ) } } Which behaves like: ./hello --name=foo Hello foo ./hello Name: foo Hello foo The default prompt string is based on the option name, but prompt takes a number of parameters to customize the output.","title":"Prompting For Input"},{"location":"options/#password-prompts","text":"You can also create a option that uses a hidden prompt and asks for confirmation. This combination of behavior is commonly used for passwords. class Login : CliktCommand () { val password by option (). prompt ( requireConfirmation = true , hideInput = true ) override fun run () { echo ( \"Your hidden password: $password\" ) } } And on the command line: $ ./login Password: Repeat for confirmation: Your hidden password: hunter2","title":"Password Prompts"},{"location":"options/#eager-options","text":"Sometimes you want an option to halt execution immediately and print a message. For example, the built-on --help option, or the --version option that many programs have. Neither of these options have any value associated with them, and they stop command line parsing as soon as they\u2019re encountered. The --help option is added automatically to commands, and --version can be added using versionOption . Since the option doesn\u2019t have a value, you can\u2019t define it using a property delegate. Instead, call the function on a command directly, either in an init block, or on a command instance. These definitions are equivalent: class Cli : NoRunCliktCommand () { init { versionOption ( \"1.0\" ) } } fun main ( args : Array < String >) = Cli (). main ( args ) and class Cli : NoRunCliktCommand () fun main ( args : Array < String >) = Cli (). versionOption ( \"1.0\" ). main ( args ) Any they work like: $ ./cli --version cli version 1.0 If you want to define your own option with a similar behavior, you can do so by creating an instance of EagerOption and passing it to CliktCommand.registerOption . EagerOption s have a callback that is called when the option is encountered on the command line. To print a message and halt execution normally from the callback, you can throw a PrintMessage exception, and CliktCommand.main will take care of printing the message. You can define your own version option like this: class Cli : CliktCommand () { init { registerOption ( EagerOption ( \"--version\" ) { throw PrintMessage ( \"$commandName version 1.0\" ) }) } override fun run () { // ... } }","title":"Eager Options"},{"location":"options/#values-from-environment-variables","text":"Clikt supports reading option values from environment variables if they aren\u2019t given on the command line. This feature is helpful when automating tools. For example, when using git commit , you can set the author date with a command line parameter: git commit --date=10/21/2015 . But you can also set it with an environment variable: GIT_AUTHOR_DATE=10/21/2015 git commit . Clikt will read option values from environment variables as long as it has an envvar name for the option. There are two ways to set that name: you can set the name manually for an option, or you can enable automatic envvar name inference. To set the envvar name manually, pass the name to option : class Hello : CliktCommand () { val name by option ( envvar = \"MY_NAME\" ) override fun run () { echo ( \"Hello $name\" ) } } And on the command line: $ export MY_NAME=Foo $ ./hello Hello Foo $ export MY_NAME=Foo $ ./hello --name=Bar Hello Bar You can enable automatic envvar name inference by setting the autoEnvvarPrefix on a command\u2019s context . This will cause all options without an explicit envvar name to be given an uppercase underscore-separated envvar name. Since the prefix is set on the context , it is propagated to subcommands. If you have a a subcommand called foo with an option --bar , and your prefix is MY_TOOL , the option\u2019s envvar name will be MY_TOOL_FOO_BAR . class Hello : CliktCommand () { init { context { autoEnvvarPrefix = \"HELLO\" } } val name by option () override fun run () { echo ( \"Hello $name\" ) } } And on the command line: $ export HELLO_NAME=Foo $ ./hello Hello Foo","title":"Values From Environment Variables"},{"location":"options/#multiple-values-from-environment-variables","text":"You might need to allow users to specify multiple values for an option in a single environment variable. You can do this by creating an option with multiple . The environment variable\u2019s value will be split according a regex, which defaults to split on whitespace for most types. file will change the pattern to split according to the operating system\u2019s path splitting rules. On Windows, it will split on semicolons ( ; ). On other systems, it will split on colons ( : ). class Hello : CliktCommand () { val names by option ( envvar = \"NAMES\" ). multiple () override fun run () { for ( name in names ) echo ( \"Hello $name\" ) } } And on the command line: $ export NAMES=Foo Bar $ ./hello Hello Foo Hello Bar","title":"Multiple Values from Environment Variables"},{"location":"options/#windows-and-java-style-option-prefixes","text":"When specifying option names manually, you can use any prefix (as long as it\u2019s entirely punctuation). For example, you can make a Windows-style interface with slashes: class Hello : CliktCommand () { val name by option ( \"/name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } An on the command line: $ ./hello /name Foo Hello, Foo! Or you can make a Java-style interface that uses single-dashes for long options: class Hello : CliktCommand () { val name by option ( \"-name\" , help = \"your name\" ) override fun run () { echo ( \"Hello, $name!\" ) } } An on the command line: $ ./hello -name Foo Hello, Foo! Note that inferred names will always have a POSIX-style prefix like --name . If you want to use a different prefix, you should specify all option names manually.","title":"Windows and Java-Style Option Prefixes"},{"location":"options/#option-transformation-order","text":"Clikt has a large number of extension functions that can modify options. When applying multiple functions to the same option, there\u2019s only one valid order for the functions to be applied. For example, option().default(3).int() will not compile, because default must be applied after the value type conversion. Similarly, you can only apply one transform of each type. So option().int().float() is invalid since int and float both change the value type, as is option().default(\"\").multiple() since default and multiple both transform the call list (if you need a custom default value for multiple , you can pass it one as an argument). Here\u2019s an integer option with one of each available transform in a valid order: val opt : Pair < Int , Int > by option ( \"-o\" , \"--opt\" ) . int () . restrictTo ( 1. . 100 ) . pair () . default ( 1 to 2 ) . validate { require ( it . second % 2 == 0 ) }","title":"Option Transformation Order"},{"location":"parameters/","text":"Parameters \u00b6 Clikt supports two types of parameters: options and positional arguments. If you\u2019re following Unix conventions with your interface, you should use options for most parameters. Options are usually optional, and arguments are frequently required. Differences \u00b6 Arguments have the advantage of being able to accepts a variable number of values, while Options are limited to a fixed number values. Other than that restriction, options have more capabilities than arguments. Options can: Act as flags (options don\u2019t have to take values) Prompt for missing input Load values from environment variables In general, you arguments are usually used for values like file paths or URLs, or for required values, and options are used for everything else. Parameter Names \u00b6 Both options and arguments can infer their names (or the metavar in the case of arguments) from the name of the property. You can also specify the names manually. Options can have any number of names, where arguments only have a single metavar. class Cli : CliktCommand () { val inferredOpt by option () val inferred by argument () val explicitOpt by option ( \"-e\" , \"--explicit\" ) val explicitArg by argument ( \"<explicit>\" ) override fun run () = Unit } The above class will generate the following help page: Usage: cli [OPTIONS] INFERRED <explicit> Options: --inferred-opt TEXT -e, --explicit TEXT -h, --help Show this message and exit Parameter Types \u00b6 Both options and arguments can convert the String that the user inputs to other types. Types work by transforming the return value of the property delegate. By default parameters have a string type: val opt : String ? by option ( help = \"an option\" ) val arg : String by argument ( help = \"an argument\" ) To convert the input to an integer, for example, use the int() extension function: val opt: Int? by option(help=\"an option\").int() val arg: Int by argument(help=\"an argument\").int() Built-In Types \u00b6 There are a number of built in types that can be applied to options and arguments. Int : option().int() and argument().int() Long : option().long() and argument().long() By default, any value that fits in the integer type is accepted. You can restrict the values to a range with restrictTo() , which allows you to either clamp the input to the range, or fail with an error if the input is outside the range. Float : option().float() and argument().float() Double : option().double() and argument().double() As with integers, you can restrict the input to a range with restrictTo() . option().choice() and argument().choice() You can restrict the values to a set of values, and optionally map the input to a new value. For example, to create an option that only accepts the value \u201cA\u201d or \u201cB\u201d: val opt : String ? by option (). choice ( \"A\" , \"B\" ) To create an argument that requires the user to choose from the values of an enum: enum class Color { RED , GREEN } val color : Color by argument (). choice ( \"RED\" to Color . RED , \"GREEN\" to Color . GREEN ) File : option().file() and argument().file() Path : option().path() and argument().path() These conversion functions take extra parameters that allow you to require that values are file paths that have certain attributes, such as that they are directories, or they are writable files. Custom Types \u00b6 You can convert parameter values to a custom type by using argument().convert() and option().convert() . These functions take a lambda that converts the input String to any type. If the parameter takes multiple values, or an option appears multiple times in argv , the conversion lambda is called once for each value. Any errors that are thrown from the lambda are automatically caught and a usage message is printed to the user. If you need to trigger conversion failure, you can use fail(\"error message\") instead of raising an exception. For example, you can create an option of type BigDecimal like this: class Cli : CliktCommand () { val opt by option (). convert { it . toBigDecimal () } override fun run () = echo ( \"opt=$opt\" ) } Calling it looks like: $ ./cli --opt=1.5 opt=1.5 $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": For input string: \"foo\" You can also pass option().convert() a metavar that will be printed in the help page instead of the default of VALUE . We can modify the above example to use a metavar and an explicit error message: class Cli : CliktCommand () { val opt by option ( help = \"a real number\" ). convert ( \"FLOAT\" ) { it . toBigDecimalOrNull () ?: fail ( \"A real number is required\" ) } override fun run () = echo ( \"opt=$opt\" ) } Which works like this: $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": A real number is required $ ./cli --help Usage: cli [OPTIONS] Options: --opt FLOAT a real number -h, --help Show this message and exit Parameter Validation \u00b6 After converting a value to a new type, you can perform additional validation on the converted value with option().validate() and argument().validate() . validate takes a lambda that returns nothing, but can call fail(\"error message\") if the value is invalid. You can also call require() , which will fail if the provided expression is false. The lambda is only called if the value is non-null. val opt by option (). int (). validate { require ( it % 2 == 0 ) { \"value must be even\" } }","title":"Differences"},{"location":"parameters/#parameters","text":"Clikt supports two types of parameters: options and positional arguments. If you\u2019re following Unix conventions with your interface, you should use options for most parameters. Options are usually optional, and arguments are frequently required.","title":"Parameters"},{"location":"parameters/#differences","text":"Arguments have the advantage of being able to accepts a variable number of values, while Options are limited to a fixed number values. Other than that restriction, options have more capabilities than arguments. Options can: Act as flags (options don\u2019t have to take values) Prompt for missing input Load values from environment variables In general, you arguments are usually used for values like file paths or URLs, or for required values, and options are used for everything else.","title":"Differences"},{"location":"parameters/#parameter-names","text":"Both options and arguments can infer their names (or the metavar in the case of arguments) from the name of the property. You can also specify the names manually. Options can have any number of names, where arguments only have a single metavar. class Cli : CliktCommand () { val inferredOpt by option () val inferred by argument () val explicitOpt by option ( \"-e\" , \"--explicit\" ) val explicitArg by argument ( \"<explicit>\" ) override fun run () = Unit } The above class will generate the following help page: Usage: cli [OPTIONS] INFERRED <explicit> Options: --inferred-opt TEXT -e, --explicit TEXT -h, --help Show this message and exit","title":"Parameter Names"},{"location":"parameters/#parameter-types","text":"Both options and arguments can convert the String that the user inputs to other types. Types work by transforming the return value of the property delegate. By default parameters have a string type: val opt : String ? by option ( help = \"an option\" ) val arg : String by argument ( help = \"an argument\" ) To convert the input to an integer, for example, use the int() extension function: val opt: Int? by option(help=\"an option\").int() val arg: Int by argument(help=\"an argument\").int()","title":"Parameter Types"},{"location":"parameters/#built-in-types","text":"There are a number of built in types that can be applied to options and arguments. Int : option().int() and argument().int() Long : option().long() and argument().long() By default, any value that fits in the integer type is accepted. You can restrict the values to a range with restrictTo() , which allows you to either clamp the input to the range, or fail with an error if the input is outside the range. Float : option().float() and argument().float() Double : option().double() and argument().double() As with integers, you can restrict the input to a range with restrictTo() . option().choice() and argument().choice() You can restrict the values to a set of values, and optionally map the input to a new value. For example, to create an option that only accepts the value \u201cA\u201d or \u201cB\u201d: val opt : String ? by option (). choice ( \"A\" , \"B\" ) To create an argument that requires the user to choose from the values of an enum: enum class Color { RED , GREEN } val color : Color by argument (). choice ( \"RED\" to Color . RED , \"GREEN\" to Color . GREEN ) File : option().file() and argument().file() Path : option().path() and argument().path() These conversion functions take extra parameters that allow you to require that values are file paths that have certain attributes, such as that they are directories, or they are writable files.","title":"Built-In Types"},{"location":"parameters/#custom-types","text":"You can convert parameter values to a custom type by using argument().convert() and option().convert() . These functions take a lambda that converts the input String to any type. If the parameter takes multiple values, or an option appears multiple times in argv , the conversion lambda is called once for each value. Any errors that are thrown from the lambda are automatically caught and a usage message is printed to the user. If you need to trigger conversion failure, you can use fail(\"error message\") instead of raising an exception. For example, you can create an option of type BigDecimal like this: class Cli : CliktCommand () { val opt by option (). convert { it . toBigDecimal () } override fun run () = echo ( \"opt=$opt\" ) } Calling it looks like: $ ./cli --opt=1.5 opt=1.5 $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": For input string: \"foo\" You can also pass option().convert() a metavar that will be printed in the help page instead of the default of VALUE . We can modify the above example to use a metavar and an explicit error message: class Cli : CliktCommand () { val opt by option ( help = \"a real number\" ). convert ( \"FLOAT\" ) { it . toBigDecimalOrNull () ?: fail ( \"A real number is required\" ) } override fun run () = echo ( \"opt=$opt\" ) } Which works like this: $ ./cli --opt=foo Usage: cli [OPTIONS] Error: Invalid value for \"--opt\": A real number is required $ ./cli --help Usage: cli [OPTIONS] Options: --opt FLOAT a real number -h, --help Show this message and exit","title":"Custom Types"},{"location":"parameters/#parameter-validation","text":"After converting a value to a new type, you can perform additional validation on the converted value with option().validate() and argument().validate() . validate takes a lambda that returns nothing, but can call fail(\"error message\") if the value is invalid. You can also call require() , which will fail if the provided expression is false. The lambda is only called if the value is non-null. val opt by option (). int (). validate { require ( it % 2 == 0 ) { \"value must be even\" } }","title":"Parameter Validation"},{"location":"quickstart/","text":"Quick Start \u00b6 You can get the library using any maven-compatible build system. Installation instructions can be found in the README . Basic Concepts \u00b6 Clikt command line interfaces are created by using property delegates inside of a CliktCommmand . The normal way to use Clikt is to forward argv from your main function to ClktCommand.main . The simplest command with no parameters would look like this: class Hello : CliktCommand () { override fun run () { echo ( \"Hello World!\" ) } } fun main ( args : Array < String >) = Hello (). main ( args ) And what it looks like to use: $ ./hello Hello World! A help page is generated automatically: $ ./hello --help Usage: hello [OPTIONS] Options: -h, --help Show this message and exit Printing to Stdout and Stderr \u00b6 Why does this example use echo instead of println ? Although println works, it can cause problems with multi-platform support. echo automatically translates line breaks into the line separator for the current platform. So you don\u2019t have to worry that some of your users will see mangled output because you didn\u2019t test on Windows. You can also pass err=true to echo to print to stderr instead of stdout. Nesting Commands \u00b6 Instances of any command can be attached to other commands, allowing arbitrary nesting of commands. For example, you could write a script to manage a database: class Database : CliktCommand () { override fun run () = Unit } class Init : CliktCommand ( help = \"Initialize the database\" ) { override fun run () { echo ( \"Initialized the database.\" ) } } class Drop : CliktCommand ( help = \"Drop the database\" ) { override fun run () { echo ( \"Dropped the database.\" ) } } fun main ( args : Array < String >) = Database () . subcommands ( Init (), Drop ()) . main ( args ) Which you can use: $ ./db init Initialized the database. And the generated help will include the subcommands: $ ./db --help Usage: database [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: init Initialize the database drop Drop the database Adding Parameters \u00b6 To add parameters, use the option and argument property delegates: class Hello : CliktCommand () { val count by option ( help = \"Number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () { for ( i in 1. . count ) { echo ( \"Hello $name!\" ) } } } Which will generate help like: $ ./hello --help Usage: hello [OPTIONS] USERNAME Options: --count INT Number of greetings -h, --help Show this message and exit Developing Command Line Applications With Gradle \u00b6 When you write a command line application, you probably want to be able to run it without invoking java -jar ... every time. If you\u2019re using Gradle, the application plugin provides a gradle task that bundles your program jars and scripts to launch them. It makes it easy to build a zip or tarball that you can distribute to your users without them needing to perform any incatations like setting up a classpath. You can see this plugin in use the in Clikt samples . The application plugin also creates tasks that will build then run your main function directly from within gradle. Although it seems like these tasks would make development easier, they are not recommended for use with command line programs. Unfortunately, due to the way gradle is designed, command line arguments are not visible to the task. Although you can hack the task to split up a gradle property and pass it in to your argv, this approach is limited. Additionally, stdin, stdout, and environment variables are all captured by gradle. All these limitations make the run task mostly useless for command line applications. An easier way to do development is to used the installDist task provided by the plugin. This builds all the distribution scripts in your build folder, which you can then execute normally. See Clikt\u2019s runsample script for an example of this approach.","title":"Basic Concepts"},{"location":"quickstart/#quick-start","text":"You can get the library using any maven-compatible build system. Installation instructions can be found in the README .","title":"Quick Start"},{"location":"quickstart/#basic-concepts","text":"Clikt command line interfaces are created by using property delegates inside of a CliktCommmand . The normal way to use Clikt is to forward argv from your main function to ClktCommand.main . The simplest command with no parameters would look like this: class Hello : CliktCommand () { override fun run () { echo ( \"Hello World!\" ) } } fun main ( args : Array < String >) = Hello (). main ( args ) And what it looks like to use: $ ./hello Hello World! A help page is generated automatically: $ ./hello --help Usage: hello [OPTIONS] Options: -h, --help Show this message and exit","title":"Basic Concepts"},{"location":"quickstart/#printing-to-stdout-and-stderr","text":"Why does this example use echo instead of println ? Although println works, it can cause problems with multi-platform support. echo automatically translates line breaks into the line separator for the current platform. So you don\u2019t have to worry that some of your users will see mangled output because you didn\u2019t test on Windows. You can also pass err=true to echo to print to stderr instead of stdout.","title":"Printing to Stdout and Stderr"},{"location":"quickstart/#nesting-commands","text":"Instances of any command can be attached to other commands, allowing arbitrary nesting of commands. For example, you could write a script to manage a database: class Database : CliktCommand () { override fun run () = Unit } class Init : CliktCommand ( help = \"Initialize the database\" ) { override fun run () { echo ( \"Initialized the database.\" ) } } class Drop : CliktCommand ( help = \"Drop the database\" ) { override fun run () { echo ( \"Dropped the database.\" ) } } fun main ( args : Array < String >) = Database () . subcommands ( Init (), Drop ()) . main ( args ) Which you can use: $ ./db init Initialized the database. And the generated help will include the subcommands: $ ./db --help Usage: database [OPTIONS] COMMAND [ARGS]... Options: -h, --help Show this message and exit Commands: init Initialize the database drop Drop the database","title":"Nesting Commands"},{"location":"quickstart/#adding-parameters","text":"To add parameters, use the option and argument property delegates: class Hello : CliktCommand () { val count by option ( help = \"Number of greetings\" ). int (). default ( 1 ) val name by argument () override fun run () { for ( i in 1. . count ) { echo ( \"Hello $name!\" ) } } } Which will generate help like: $ ./hello --help Usage: hello [OPTIONS] USERNAME Options: --count INT Number of greetings -h, --help Show this message and exit","title":"Adding Parameters"},{"location":"quickstart/#developing-command-line-applications-with-gradle","text":"When you write a command line application, you probably want to be able to run it without invoking java -jar ... every time. If you\u2019re using Gradle, the application plugin provides a gradle task that bundles your program jars and scripts to launch them. It makes it easy to build a zip or tarball that you can distribute to your users without them needing to perform any incatations like setting up a classpath. You can see this plugin in use the in Clikt samples . The application plugin also creates tasks that will build then run your main function directly from within gradle. Although it seems like these tasks would make development easier, they are not recommended for use with command line programs. Unfortunately, due to the way gradle is designed, command line arguments are not visible to the task. Although you can hack the task to split up a gradle property and pass it in to your argv, this approach is limited. Additionally, stdin, stdout, and environment variables are all captured by gradle. All these limitations make the run task mostly useless for command line applications. An easier way to do development is to used the installDist task provided by the plugin. This builds all the distribution scripts in your build folder, which you can then execute normally. See Clikt\u2019s runsample script for an example of this approach.","title":"Developing Command Line Applications With Gradle"},{"location":"utilities/","text":"Utilities \u00b6 Writing command line interfaces often involves more than just parsing the command line. Clikt also provides functions to perform actions commonly used in command line programs. Launching Editors \u00b6 If you need to ask users for multi-line input, or need to have the user edit a file, you can do so through TermUi.editText and TermUi.editFile . These functions open the program defined in the VISUAL or EDITOR environment variables, or a sensible default if neither are defined. The functions return the edited text if the user saved their changes. For example: fun getCommitMessage (): String ? { return TermUi . editText ( \"\\n\" + \"\\n# Enter your message. \" + \"\\n# Lines starting with # are ignored\" , requireSave = true ) ?. replace ( Regex ( \"#[^\\n]*\\n\" ), \"\" ) } Input Prompts \u00b6 Options can prompt for values automatically , but you can also do so manually with TermUi.prompt . By default, it accepts any input string, but you can also pass in a conversion function. If the conversion raises a UsageError , the prompt will ask the user to enter a different value. val input = TermUi . prompt ( \"Enter a number\" ) { it . toIntOrNull () ?: throw UsageError ( \"$it is not a valid integer\" ) } TermUi . echo ( \"Twice your number is ${input * 2}\" ) Which will produce interactive sessions like this: Enter a number: foo Error: foo is not a valid integer Enter a number: 11 Twice your number is 22 Confirmation Prompts \u00b6 You can also ask the user for a yes or no response with TermUi.confirm : if ( TermUi . confirm ( \"Continue?\" ) == true ) { TermUi . echo ( \"OK!\" ) } If you simply want to abort the program in the user gives a negative response, you can pass abort=true : TermUi . confirm ( \"Continue?\" , abort = true )","title":"Launching Editors"},{"location":"utilities/#utilities","text":"Writing command line interfaces often involves more than just parsing the command line. Clikt also provides functions to perform actions commonly used in command line programs.","title":"Utilities"},{"location":"utilities/#launching-editors","text":"If you need to ask users for multi-line input, or need to have the user edit a file, you can do so through TermUi.editText and TermUi.editFile . These functions open the program defined in the VISUAL or EDITOR environment variables, or a sensible default if neither are defined. The functions return the edited text if the user saved their changes. For example: fun getCommitMessage (): String ? { return TermUi . editText ( \"\\n\" + \"\\n# Enter your message. \" + \"\\n# Lines starting with # are ignored\" , requireSave = true ) ?. replace ( Regex ( \"#[^\\n]*\\n\" ), \"\" ) }","title":"Launching Editors"},{"location":"utilities/#input-prompts","text":"Options can prompt for values automatically , but you can also do so manually with TermUi.prompt . By default, it accepts any input string, but you can also pass in a conversion function. If the conversion raises a UsageError , the prompt will ask the user to enter a different value. val input = TermUi . prompt ( \"Enter a number\" ) { it . toIntOrNull () ?: throw UsageError ( \"$it is not a valid integer\" ) } TermUi . echo ( \"Twice your number is ${input * 2}\" ) Which will produce interactive sessions like this: Enter a number: foo Error: foo is not a valid integer Enter a number: 11 Twice your number is 22","title":"Input Prompts"},{"location":"utilities/#confirmation-prompts","text":"You can also ask the user for a yes or no response with TermUi.confirm : if ( TermUi . confirm ( \"Continue?\" ) == true ) { TermUi . echo ( \"OK!\" ) } If you simply want to abort the program in the user gives a negative response, you can pass abort=true : TermUi . confirm ( \"Continue?\" , abort = true )","title":"Confirmation Prompts"},{"location":"whyclikt/","text":"Why Clikt? \u00b6 There are existing Kotlin libraries for creating command line interfaces, and many Java libraries work in Kotlin as well. However, none of them had all of the following features: Unrestricted composability of commands Fully static type safety for parameters Composable parameter customization that doesn\u2019t require registering converter objects. Full support for Unix command line conventions Capable of reading parameter values from environment variables out of the box Included support for common functionality (keyboard interactivity, line ending normalization, launching editors, etc.) Built-in support for multi-token command aliases Clikt is focused on making writing robust, posix-compliant command line interfaces as easy as possible. A good CLI does more than just parse argv . It allows users to specify values in environment variables, and in some cases prompts for additional input, or opens an editor. Clikt supports all of this out of the box. Some times you need to make a CLI that doesn\u2019t follow Unix conventions. You might be writing for windows, or you want to use the Java style of long options with a single dash. Maybe you need to use a bunch of required options instead of arguments, or you want the help page formatted differently. \u201cBest practices\u201d might not be the best for you, so Clikt tries to make implementing uncommon use-cases as easy as possible. Why not a Kotlin library like kotlin-argparse or kotlinx.cli? \u00b6 Clikt didn\u2019t invent the idea of a property delegate-based cli parser. JetBrains made kotlinx.cli , which is functional, but is more of a proof-of-concept than a production ready library. kotlin-argparser builds off of kotlinx.cli , and works well for simple cases. It\u2019s missing a lot of features that Clikt has, but features can be added. Its real drawback is that it fundamentally does not support composition of commands or parameter values. The lack of subcommand support was already a non-starter, but there are other design descisions that make it unsuitable. In the simple cases, the two libraries are similar. Here\u2019s an example from its README: class MyArgs ( parser : ArgParser ) { val v : Boolean by parser . flagging ( help = \"enable verbose mode\" ) val username : String ? by parser . storing ( help = \"name of the user\" ) val count : Int ? by parser . storing ( help = \"number of the widgets\" ) { toInt () } val source : List < String > by parser . positionalList ( help = \"source filenames\" ) val destination : String by parser . positional ( help = \"destination\" ) } fun main ( args : Array < String >) = mainBody { ArgParser ( args ). parseInto ( :: MyArgs ). run { println ( \"Hello, $username!\" ) println ( \"Moving $count widgets from $source to $destination.\" ) } } Here\u2019s the same thing with Clikt: class Cli : CliktCommand () { val v : Boolean by option ( help = \"enable verbose mode\" ). flag () val username : String ? by option ( help = \"name of the user\" ) val count : Int ? by option ( help = \"number of the widgets\" ). int () val source : List < String > by argument ( help = \"source filenames\" ). multiple () val destination : String by argument ( help = \"destination\" ) override fun run () { println ( \"Hello, $name!\" ) println ( \"Moving $count widgets from $source to $destination.\" ) } } fun main ( args : Array < String >) = Cli (). main ( args ) Both work fine, although you may find Clikt more consistent and a bit less verbose. The differences become more pronounced once you try to do anything that isn\u2019t built in to kotlin-argparser . Maybe you need an option to take two values. Here\u2019s another example from the kotlin-argparser README showing how to do that: fun ArgParser . putting ( vararg names : String , help : String ) = option < MutableMap < String , String >>(* names , argNames = listOf ( \"KEY\" , \"VALUE\" ), help = help ) { value . orElse { mutableMapOf < String , String >() }. apply { put ( arguments . first (), arguments . last ()) } } fun ArgParser . putting ( help : String ) = ArgParser . DelegateProvider { identifier -> putting ( identifierToOptionName ( identifier ), help = help ) } class MyArgs ( parser : ArgParser ) { val v by parser . putting ( help = \"this takes two values\" ) } Clikt has that functionality built in as option().pair() , but you could implement it yourself like this: class Cli : CliktCommand () { val v by option ( help = \"this takes two values\" ). transformValues ( 2 ) { it [ 0 ] to it [ 1 ] } } The Clikt version is of course much simpler, but there are more fundamental issues with the kotlin-argparser version that drove the creation of Clikt: Its inheritance-based design means that if you wanted to change the type of each value, you would have to copy all of the code for each type. With Clikt, you could just do option().int().transformValues(2) { it[0] to it[1] } Its inheritance-based design means that supporting types, multiple values, and multiple option occurrences would require a combinatorial copies of the above code. With Clikt, these are all orthoganal. You have to do all error checking yourself. The argparser example silently discards extra values, or copies the single value, rather than inform the user of the mistake. You could write more code to do so, but Clikt takes care of it for you. Option name inference is not automatic, requiring you to wrap the delegate with yet another function. Each delegate function has a different name, with no indication of whether its creating an option or positional argument. With Clikt, all options are created with option() , and all arguments with argument() . Some of these problems can be solved by writing more code, and some can\u2019t. On the other hand, Clikt attempts to consistent, intuitive, composable interface that tries to do the right thing without forcing you to think about edge cases. Why not a Java library like JCommander? \u00b6 There are a lot of command line libraries for Java. Most are verbose and not composable. One popular Java library that is usable from Kotlin is JCommander . JCommander uses annotations to define parameters, and reflection to set fields. This is functional for simple types, but defining your own types requires you to register a type adapter with the JCommander builder. This means that type errors are not caught until runtime, and many types of customization are not possible. For example, options that take multiple values cannot be converted to other types. The JCommander docs explain: \u2026 only List is allowed for parameters that define an arity. You will have to convert these values yourself if the parameters you need are of type Integer or other (this limitation is due to Java\u2019s erasure). You also can\u2019t customize many aspect of parsing in JCommander. It can\u2019t infer parameter names. With JCommander, you can\u2019t have an option with multiple values and multiple occurrences at the same time. You can\u2019t have more than one argument, and it can only take one value or an unlimited number of values. You can\u2019t nest subcommands. JCommander is a great library if you\u2019re writing code in Java, but we can do much better with Kotlin.","title":"Why not a Kotlin library like kotlin-argparse or kotlinx.cli?"},{"location":"whyclikt/#why-clikt","text":"There are existing Kotlin libraries for creating command line interfaces, and many Java libraries work in Kotlin as well. However, none of them had all of the following features: Unrestricted composability of commands Fully static type safety for parameters Composable parameter customization that doesn\u2019t require registering converter objects. Full support for Unix command line conventions Capable of reading parameter values from environment variables out of the box Included support for common functionality (keyboard interactivity, line ending normalization, launching editors, etc.) Built-in support for multi-token command aliases Clikt is focused on making writing robust, posix-compliant command line interfaces as easy as possible. A good CLI does more than just parse argv . It allows users to specify values in environment variables, and in some cases prompts for additional input, or opens an editor. Clikt supports all of this out of the box. Some times you need to make a CLI that doesn\u2019t follow Unix conventions. You might be writing for windows, or you want to use the Java style of long options with a single dash. Maybe you need to use a bunch of required options instead of arguments, or you want the help page formatted differently. \u201cBest practices\u201d might not be the best for you, so Clikt tries to make implementing uncommon use-cases as easy as possible.","title":"Why Clikt?"},{"location":"whyclikt/#why-not-a-kotlin-library-like-kotlin-argparse-or-kotlinxcli","text":"Clikt didn\u2019t invent the idea of a property delegate-based cli parser. JetBrains made kotlinx.cli , which is functional, but is more of a proof-of-concept than a production ready library. kotlin-argparser builds off of kotlinx.cli , and works well for simple cases. It\u2019s missing a lot of features that Clikt has, but features can be added. Its real drawback is that it fundamentally does not support composition of commands or parameter values. The lack of subcommand support was already a non-starter, but there are other design descisions that make it unsuitable. In the simple cases, the two libraries are similar. Here\u2019s an example from its README: class MyArgs ( parser : ArgParser ) { val v : Boolean by parser . flagging ( help = \"enable verbose mode\" ) val username : String ? by parser . storing ( help = \"name of the user\" ) val count : Int ? by parser . storing ( help = \"number of the widgets\" ) { toInt () } val source : List < String > by parser . positionalList ( help = \"source filenames\" ) val destination : String by parser . positional ( help = \"destination\" ) } fun main ( args : Array < String >) = mainBody { ArgParser ( args ). parseInto ( :: MyArgs ). run { println ( \"Hello, $username!\" ) println ( \"Moving $count widgets from $source to $destination.\" ) } } Here\u2019s the same thing with Clikt: class Cli : CliktCommand () { val v : Boolean by option ( help = \"enable verbose mode\" ). flag () val username : String ? by option ( help = \"name of the user\" ) val count : Int ? by option ( help = \"number of the widgets\" ). int () val source : List < String > by argument ( help = \"source filenames\" ). multiple () val destination : String by argument ( help = \"destination\" ) override fun run () { println ( \"Hello, $name!\" ) println ( \"Moving $count widgets from $source to $destination.\" ) } } fun main ( args : Array < String >) = Cli (). main ( args ) Both work fine, although you may find Clikt more consistent and a bit less verbose. The differences become more pronounced once you try to do anything that isn\u2019t built in to kotlin-argparser . Maybe you need an option to take two values. Here\u2019s another example from the kotlin-argparser README showing how to do that: fun ArgParser . putting ( vararg names : String , help : String ) = option < MutableMap < String , String >>(* names , argNames = listOf ( \"KEY\" , \"VALUE\" ), help = help ) { value . orElse { mutableMapOf < String , String >() }. apply { put ( arguments . first (), arguments . last ()) } } fun ArgParser . putting ( help : String ) = ArgParser . DelegateProvider { identifier -> putting ( identifierToOptionName ( identifier ), help = help ) } class MyArgs ( parser : ArgParser ) { val v by parser . putting ( help = \"this takes two values\" ) } Clikt has that functionality built in as option().pair() , but you could implement it yourself like this: class Cli : CliktCommand () { val v by option ( help = \"this takes two values\" ). transformValues ( 2 ) { it [ 0 ] to it [ 1 ] } } The Clikt version is of course much simpler, but there are more fundamental issues with the kotlin-argparser version that drove the creation of Clikt: Its inheritance-based design means that if you wanted to change the type of each value, you would have to copy all of the code for each type. With Clikt, you could just do option().int().transformValues(2) { it[0] to it[1] } Its inheritance-based design means that supporting types, multiple values, and multiple option occurrences would require a combinatorial copies of the above code. With Clikt, these are all orthoganal. You have to do all error checking yourself. The argparser example silently discards extra values, or copies the single value, rather than inform the user of the mistake. You could write more code to do so, but Clikt takes care of it for you. Option name inference is not automatic, requiring you to wrap the delegate with yet another function. Each delegate function has a different name, with no indication of whether its creating an option or positional argument. With Clikt, all options are created with option() , and all arguments with argument() . Some of these problems can be solved by writing more code, and some can\u2019t. On the other hand, Clikt attempts to consistent, intuitive, composable interface that tries to do the right thing without forcing you to think about edge cases.","title":"Why not a Kotlin library like kotlin-argparse or kotlinx.cli?"},{"location":"whyclikt/#why-not-a-java-library-like-jcommander","text":"There are a lot of command line libraries for Java. Most are verbose and not composable. One popular Java library that is usable from Kotlin is JCommander . JCommander uses annotations to define parameters, and reflection to set fields. This is functional for simple types, but defining your own types requires you to register a type adapter with the JCommander builder. This means that type errors are not caught until runtime, and many types of customization are not possible. For example, options that take multiple values cannot be converted to other types. The JCommander docs explain: \u2026 only List is allowed for parameters that define an arity. You will have to convert these values yourself if the parameters you need are of type Integer or other (this limitation is due to Java\u2019s erasure). You also can\u2019t customize many aspect of parsing in JCommander. It can\u2019t infer parameter names. With JCommander, you can\u2019t have an option with multiple values and multiple occurrences at the same time. You can\u2019t have more than one argument, and it can only take one value or an unlimited number of values. You can\u2019t nest subcommands. JCommander is a great library if you\u2019re writing code in Java, but we can do much better with Kotlin.","title":"Why not a Java library like JCommander?"}]}